# Introduction
This is a best practice guide that is foundationally rooted in addressing the most common security concerns identified with Web APIs by OWASP, and layered with other standards that are from the likes of Microsoft, Google, IBM and more.

I believe that a collaborative, community-driven document is needed by the industry so that we are the driving force behind the common practices and standards. 

Following the following sections can, and will, help ensure that client experience is solid, by being:

- Seamless and Simple
- Efficient
- Consistent patterns across the API; Error Messages, Status 
is as seamless and simple as possible:




Simple, Consistent, Easy To Use, Adaptable , Efficient, Effective, Self-explanatory. This isn’t a do or don’t, this is amalgamation of standards that as a developer, you should follow, to promote those keywords.


We will be using keywords that should be interpreted as described in BCP 14, RFC2119, RFC8174. These are "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL”.


## Overview Summary

The following sections cover the key takeaways from each of the identified themes of best practices and standards for REST APIs. This list follows;



- Background information on REST and HTTP, how it should be used.


- Resource and Design patterns and standards



## Defining Principles: REST and HTTP
REST and HTTP are the defining factors of the internet and ,

 the following sections break down how the services should best use these technologies.  



### Representational State Transfer (REST) and the HTTP Specification
REST is a network architecture and we use HTTP enable communicatons between our 

--JSON 
--URI Patterns, values
--Hypermedia 
--Custom Methods
Stateless requests.

- URI patterns.
- HTTP, request and responses
- Query Paramters (Sorting and Limiting Fields) and Headers



For the official HTTP Specification, visit [RFC7231](https://datatracker.ietf.org/doc/html/rfc7231) for more information. This section discusses what constraints, patterns and standards should be employed.



Verbs and Nouns
Idempotency
HTTP Status codes
Requests and Responses

Query paramters and headers
Content types,
Data types


Supporting Caching and optimisation with the 



## API Access Control and Security
Security is by **far** the most important aspect of creating a REST API. Broken access control and securtiy
Broken access control being a leading factor in OWASP top 10.
--Validation, Securing and validating

Keeping components separate from another is another key principle of REST. The API services can be broken down into three, distinct layers, however they may vary from name / quantity depedent on the system. 

-	Presentation Layer 
-	Logic Layer
-	Data Layer


JWTs and API keys should be used as an extra layer of security, making sure that only authorised clients are able to access the API's services. They are typically generated by the service and given to the client securely.

Audit logs of large transactions and users interactions should be kept for moderation.

Store logs of failed logins, failed requests and large transactions. These two logs can be critical in identifying problematic actors and tracking issues within the system.

Data that is coming in, any of it, should be validated against to ensure that is the right type and the right length. Status code 400-Bad Request should be returned as the server cannot process the request.


Locally authenticate each endpoint. Assume that each request has "Least Privilege" from the get-go, meaning that any user's default access level is set as "denied" until given permission. This could be added to the clients headers.

Client data should be sanitised to protect against SQL Injections. Sanitisation is stripping the inputs of any escape characters to stop any sort of malicious code being ran on the system.

Deleted data should be retained for X amount of days before being erased completely. Clients should have the ability to rollback their changes so that data can be recovered promptly.



Validating against Cross site request forger

Rate Limiting - Headers, Services implemented? Retuurning 429- Too many requests


## Common API Implementation Practices
Requests can sometimes take longer than expected to process, in which case the client should have a 202-Accepted Status code returned to show that the request has been accepted, as well as a URI that can be used to show the progress. This is referred to as an Long Running Operation(LRO)

Supporting Partial responses -- Is t


Do not let your API be chatty. When designing your API, keep in mind the 
workflow? Client journey? REsource Consumption



## Exception handling and Error Logging
Error logs should be kept and maintained regularly. They should be in a consistent format, and it should store any malicious

Returning the correct status code to the client is a main factor of maintaining a services reliability. The most common ones that should be returned per HTTP method can be found below:

| HTTP Method | Successful Response (2xx)       | Client Error Response (4xx)         | 
|-------------|---------------------------------|--------------------------------------|
| GET         | 200 OK                          | 404 Not Found                        |
| POST        | 201 Created                     | 400 Bad Request                      | 
| PUT         | 200 OK (or 201 Created)         | 404 Not Found                        |
| DELETE      | 200 OK (or 204 No Content)      | 404 Not Found                        |
| PATCH       | 200 OK (or 204 No Content)      | 404 Not Found                        |

Error messages attached should be meangingful and relevant to the situation, i.e, if a parameter is missing / incorrect, then the message should indicate such.

## Filtering Responses

Pagination splits large collections into "pages", which are chunks of data that can be specified by the client. This should be implemented if resource collections are bound to get large. 

The URI should follow a similar pattern as below:

```text
GET https://**/*collection*?limit=XX&offset=XX
```

Take the below example:

```text
GET https://bpg-library.com/orders?limit=5&offset=8
```
This is telling the endpoint to return a dataset maximum of 5, using the order specified by the offset value of 8. This will return the first 5 books after the 8th record stored.


URI Query parameters should be accepted by the API. URI Structure for performing actions on resource collections should follow the below format:

```
https://.../*collection*/*id*:*action*?*parameters*
```


## Caching and Optimisation
Caching **must** be available for clients using a REST API. Not only is it a principle of the REST architecture, it cuts latency and network bandwidth usage by the API and the client just by sup
porting it. Caching enables clients to store responses from previous requests to minimise the amount of traffic to the API.

- GET Methods can be cached by default.

- Do not allow sensitive data to be cacheable.

### Cache Control

Clide-Side Caching can be done by clients adding request headers to provide the information on caching the resource. It is called "[Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)".

The API should support the Cache Control headers of:

| Header           | Description                                                             |
|------------------|-------------------------------------------------------------------------|
| Max-age          | The maximum time in seconds for how long the cache will exist.          |
| Private          | Indicates that the response is only cacheable on the client’s browser.  |
| Public           | Indicates that the response is publicly cacheable.                      |
| No-Cache         | Indicates that the response can be cached, but it will be revalidated by the API before used. |
| No-Store         | Response cannot be cached by the client.                                |
| Must-Revalidate | Indicates the cached response must be revalidated before being used.   |



### ETags

An ETag, or Entity Tag, is a digital fingerprint of a resource. Returning an ETag value with a GET or HEAD will allow caching of unchanged resources. 






## Versioning


Versioning comes as apart of the natural lifecycle the API will go through. Changes can be introduced that adds or alters existing functionality, and these changes may affect clients current usage. This is referrred to as a "breaking change". 

Versioning must be done carefully to ensure that a clients workflow is not disrupted. For example, if a resource has been renamed, or a method removed, and the client requires it to complete their workload, that is a "breaking change".

Clients must be able to indicate which version of the API they wish to access, and they should do that through one of these methods:
- Versioning through the **URI**.

```text
 GET   https://bpglibrary-official.com/v1/orders/3
 ...
```

- Versioning through **Custom Header Paramters**.

```text
 GET   https://bpglibrary-official.com/orders/3
 Custom-Header: api-version=2
 ...
```

If the client has not entered an incorrect header or has an incorrect API version, a status code of 400 and an apt message should be returned to the client.

As long as the indication of the version is clear, the format and context can be depedent on the developer.


Developers may also have scenarios where as their RESTful API grows, new functionality can be added without disrupting clients workloads. In these scenarios, it is not requied and it would not be worth versioning the API to avoid potential confusion.